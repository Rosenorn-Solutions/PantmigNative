/* tslint:disable */
/* eslint-disable */
/**
 * PantmigService API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AcceptRequest,
  ApplicantInfo,
  CancelRequest,
  ChatStartRequest,
  CreateRecycleListingRequest,
  MeetingPointRequest,
  PickupConfirmRequest,
  PickupRequest,
  RecycleListingResponse,
} from '../models/index';
import {
    AcceptRequestFromJSON,
    AcceptRequestToJSON,
    ApplicantInfoFromJSON,
    ApplicantInfoToJSON,
    CancelRequestFromJSON,
    CancelRequestToJSON,
    ChatStartRequestFromJSON,
    ChatStartRequestToJSON,
    CreateRecycleListingRequestFromJSON,
    CreateRecycleListingRequestToJSON,
    MeetingPointRequestFromJSON,
    MeetingPointRequestToJSON,
    PickupConfirmRequestFromJSON,
    PickupConfirmRequestToJSON,
    PickupRequestFromJSON,
    PickupRequestToJSON,
    RecycleListingResponseFromJSON,
    RecycleListingResponseToJSON,
} from '../models/index';

export interface ListingsApplicantsGetRequest {
    id: number;
}

export interface ListingsCancelRequest {
    cancelRequest: CancelRequest;
}

export interface ListingsChatStartRequest {
    chatStartRequest: ChatStartRequest;
}

export interface ListingsCreateRequest {
    createRecycleListingRequest: CreateRecycleListingRequest;
}

export interface ListingsGetByIdRequest {
    id: number;
}

export interface ListingsMeetingSetRequest {
    meetingPointRequest: MeetingPointRequest;
}

export interface ListingsPickupAcceptRequest {
    acceptRequest: AcceptRequest;
}

export interface ListingsPickupConfirmRequest {
    pickupConfirmRequest: PickupConfirmRequest;
}

export interface ListingsPickupRequestRequest {
    pickupRequest: PickupRequest;
}

export interface ListingsReceiptUploadRequest {
    listingId: number;
    reportedAmount: number;
    file: Blob;
}

/**
 * 
 */
export class RecycleListingsApi extends runtime.BaseAPI {

    /**
     * Donator retrieves the list of applicants with their user IDs and appliedAt timestamps.
     * Get applicants for a listing
     */
    async listingsApplicantsGetRaw(requestParameters: ListingsApplicantsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApplicantInfo>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listingsApplicantsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/{id}/applicants`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApplicantInfoFromJSON));
    }

    /**
     * Donator retrieves the list of applicants with their user IDs and appliedAt timestamps.
     * Get applicants for a listing
     */
    async listingsApplicantsGet(requestParameters: ListingsApplicantsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApplicantInfo>> {
        const response = await this.listingsApplicantsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Donator cancels their own listing if not already completed or cancelled.
     * Cancel a listing
     */
    async listingsCancelRaw(requestParameters: ListingsCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['cancelRequest'] == null) {
            throw new runtime.RequiredError(
                'cancelRequest',
                'Required parameter "cancelRequest" was null or undefined when calling listingsCancel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/cancel`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CancelRequestToJSON(requestParameters['cancelRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Donator cancels their own listing if not already completed or cancelled.
     * Cancel a listing
     */
    async listingsCancel(requestParameters: ListingsCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsCancelRaw(requestParameters, initOverrides);
    }

    /**
     * Starts a chat between the donator and the assigned recycler for the listing.
     * Start a direct chat for a listing
     */
    async listingsChatStartRaw(requestParameters: ListingsChatStartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['chatStartRequest'] == null) {
            throw new runtime.RequiredError(
                'chatStartRequest',
                'Required parameter "chatStartRequest" was null or undefined when calling listingsChatStart().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/chat/start`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatStartRequestToJSON(requestParameters['chatStartRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Starts a chat between the donator and the assigned recycler for the listing.
     * Start a direct chat for a listing
     */
    async listingsChatStart(requestParameters: ListingsChatStartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsChatStartRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new recycle listing with structured item contents. Supports either JSON body (application/json) or multipart/form-data (fields: title, description, city/location, availableFrom, availableTo, optional pickupTimeFrom/pickupTimeTo, items as JSON string, images as image/_*). Requires a verified Donator.
     * Create a new listing
     */
    async listingsCreateRaw(requestParameters: ListingsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['createRecycleListingRequest'] == null) {
            throw new runtime.RequiredError(
                'createRecycleListingRequest',
                'Required parameter "createRecycleListingRequest" was null or undefined when calling listingsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRecycleListingRequestToJSON(requestParameters['createRecycleListingRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new recycle listing with structured item contents. Supports either JSON body (application/json) or multipart/form-data (fields: title, description, city/location, availableFrom, availableTo, optional pickupTimeFrom/pickupTimeTo, items as JSON string, images as image/_*). Requires a verified Donator.
     * Create a new listing
     */
    async listingsCreate(requestParameters: ListingsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsCreateRaw(requestParameters, initOverrides);
    }

    /**
     * Returns all listings that are currently active and available.
     * Get active recycle listings
     */
    async listingsGetActiveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RecycleListingResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecycleListingResponseFromJSON));
    }

    /**
     * Returns all listings that are currently active and available.
     * Get active recycle listings
     */
    async listingsGetActive(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RecycleListingResponse>> {
        const response = await this.listingsGetActiveRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a single recycle listing by its identifier.
     * Get a listing by id
     */
    async listingsGetByIdRaw(requestParameters: ListingsGetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecycleListingResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listingsGetById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecycleListingResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a single recycle listing by its identifier.
     * Get a listing by id
     */
    async listingsGetById(requestParameters: ListingsGetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecycleListingResponse> {
        const response = await this.listingsGetByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Donator sets the meeting point coordinates. Requires chat to be started.
     * Set meeting point for a listing
     */
    async listingsMeetingSetRaw(requestParameters: ListingsMeetingSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['meetingPointRequest'] == null) {
            throw new runtime.RequiredError(
                'meetingPointRequest',
                'Required parameter "meetingPointRequest" was null or undefined when calling listingsMeetingSet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/meeting/set`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MeetingPointRequestToJSON(requestParameters['meetingPointRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Donator sets the meeting point coordinates. Requires chat to be started.
     * Set meeting point for a listing
     */
    async listingsMeetingSet(requestParameters: ListingsMeetingSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsMeetingSetRaw(requestParameters, initOverrides);
    }

    /**
     * Returns all listings created by the authenticated donator, including cancelled and completed.
     * Get my listings
     */
    async listingsMyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RecycleListingResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/my-listings`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecycleListingResponseFromJSON));
    }

    /**
     * Returns all listings created by the authenticated donator, including cancelled and completed.
     * Get my listings
     */
    async listingsMy(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RecycleListingResponse>> {
        const response = await this.listingsMyRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns all listings the authenticated recycler has applied to.
     * Get my applications
     */
    async listingsMyApplicationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RecycleListingResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/my-applications`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecycleListingResponseFromJSON));
    }

    /**
     * Returns all listings the authenticated recycler has applied to.
     * Get my applications
     */
    async listingsMyApplications(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RecycleListingResponse>> {
        const response = await this.listingsMyApplicationsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Donator selects one of the applicants and accepts them for pickup.
     * Accept a recycler for pickup
     */
    async listingsPickupAcceptRaw(requestParameters: ListingsPickupAcceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['acceptRequest'] == null) {
            throw new runtime.RequiredError(
                'acceptRequest',
                'Required parameter "acceptRequest" was null or undefined when calling listingsPickupAccept().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/pickup/accept`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AcceptRequestToJSON(requestParameters['acceptRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Donator selects one of the applicants and accepts them for pickup.
     * Accept a recycler for pickup
     */
    async listingsPickupAccept(requestParameters: ListingsPickupAcceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsPickupAcceptRaw(requestParameters, initOverrides);
    }

    /**
     * Donator confirms that the pickup has been performed (after chat and meeting point). This completes the listing.
     * Confirm pickup and complete listing
     */
    async listingsPickupConfirmRaw(requestParameters: ListingsPickupConfirmRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['pickupConfirmRequest'] == null) {
            throw new runtime.RequiredError(
                'pickupConfirmRequest',
                'Required parameter "pickupConfirmRequest" was null or undefined when calling listingsPickupConfirm().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/pickup/confirm`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PickupConfirmRequestToJSON(requestParameters['pickupConfirmRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Donator confirms that the pickup has been performed (after chat and meeting point). This completes the listing.
     * Confirm pickup and complete listing
     */
    async listingsPickupConfirm(requestParameters: ListingsPickupConfirmRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsPickupConfirmRaw(requestParameters, initOverrides);
    }

    /**
     * Recycler requests to pick up a specific listing. Adds the recycler to the applicants list.
     * Request pickup for a listing
     */
    async listingsPickupRequestRaw(requestParameters: ListingsPickupRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['pickupRequest'] == null) {
            throw new runtime.RequiredError(
                'pickupRequest',
                'Required parameter "pickupRequest" was null or undefined when calling listingsPickupRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }


        let urlPath = `/listings/pickup/request`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PickupRequestToJSON(requestParameters['pickupRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Recycler requests to pick up a specific listing. Adds the recycler to the applicants list.
     * Request pickup for a listing
     */
    async listingsPickupRequest(requestParameters: ListingsPickupRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsPickupRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Recycler uploads the receipt image as multipart/form-data with fields: listingId, reportedAmount, file. This does not affect listing status and is available even after completion.
     * Upload receipt image
     */
    async listingsReceiptUploadRaw(requestParameters: ListingsReceiptUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['listingId'] == null) {
            throw new runtime.RequiredError(
                'listingId',
                'Required parameter "listingId" was null or undefined when calling listingsReceiptUpload().'
            );
        }

        if (requestParameters['reportedAmount'] == null) {
            throw new runtime.RequiredError(
                'reportedAmount',
                'Required parameter "reportedAmount" was null or undefined when calling listingsReceiptUpload().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling listingsReceiptUpload().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['listingId'] != null) {
            formParams.append('listingId', requestParameters['listingId'] as any);
        }

        if (requestParameters['reportedAmount'] != null) {
            formParams.append('reportedAmount', requestParameters['reportedAmount'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/listings/receipt/upload`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Recycler uploads the receipt image as multipart/form-data with fields: listingId, reportedAmount, file. This does not affect listing status and is available even after completion.
     * Upload receipt image
     */
    async listingsReceiptUpload(requestParameters: ListingsReceiptUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listingsReceiptUploadRaw(requestParameters, initOverrides);
    }

}
